// Copyright 2024 Goldman Sachs
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import meta::pure::changetoken::*;
import meta::pure::functions::meta::*;
import meta::pure::functions::hash::*;
import meta::pure::metamodel::serialization::grammar::*;
import meta::pure::changetoken::cast_generation::*;
import meta::pure::changetoken::diff_generation::*;
import meta::pure::functions::collection::*;
import meta::json::*;

function meta::pure::changetoken::diff_generation::generateDiffFromVersions(versions:Versions[1], propertyRenames:Map<String, Map<String, String>>[0..1], classRenames:Map<String, String>[0..1], defaultValues:Map<String, Map<String, Any>>[0..1]):Versions[1]
{
    $versions->generateDiffFromVersionsAndScopes('new::entities::vX_X_X', 'old::entities::vX_X_X', $propertyRenames, $classRenames, $defaultValues);
}

function meta::pure::changetoken::diff_generation::generateDiffFromVersionsAndScopes(versions:Versions[1], newScope:String[1], oldScope:String[1], propertyRenames:Map<String, Map<String, String>>[0..1], classRenames:Map<String, String>[0..1], defaultValues:Map<String, Map<String, Any>>[0..1]):Versions[1]
{
    let newClasses = getClasses($newScope);
    let oldClasses = getClasses($oldScope);
    generateDiffFromVersionsAndClasses($versions, $newClasses, $oldClasses, $propertyRenames, $classRenames, $defaultValues);
}

function meta::pure::changetoken::diff_generation::getClasses(scope:String[1]):Class<Any>[*]
{
    let entities = $scope->pathToPackage(true);
    $entities->packageClassesRecursive();
}

function meta::pure::changetoken::diff_generation::generateDiffFromVersionsAndClasses(versions:Versions[1], newClasses:Class<Any>[*], oldClasses:Class<Any>[*], propertyRenames:Map<String, Map<String, String>>[0..1], classRenames:Map<String, String>[0..1], defaultValues:Map<String, Map<String, Any>>[0..1]):Versions[1]
{
    let prevVersion = if($versions.versions->size() > 0, | $versions.versions->at($versions.versions->size() - 1).version, | []);
    let version = ^Version(
            version=getHash($prevVersion, getHashTokens($newClasses)),
            prevVersion=$prevVersion,
            changeTokens=getChangeTokens($newClasses, $oldClasses, $propertyRenames, $classRenames, $defaultValues)
    );
    ^Versions(versions=concatenate($versions.versions, [$version]));
}

function meta::pure::changetoken::diff_generation::getHash(prevVersion:String[0..1], tokens:String[*]):String[1]
{
    hash($prevVersion->concatenate($tokens)->joinStrings(), HashType.SHA1);
}

function meta::pure::changetoken::diff_generation::getHashTokens(classes:Class<Any>[*]):String[*]
{
    $classes
    ->sort({x,y | stripedPaths($x, $y) })
    ->map(c | stripPath($c)->concatenate($c.properties
    ->filter(p | $p.name != 'version')
    ->sort({x,y | $x.name->toOne()->compare($y.name->toOne()) })
    ->map(p | $p.name->toOne()->concatenate(stripVersionQualifier(printGenericType($p.genericType)) + '[' + printMultiplicity($p.multiplicity) + ']'))));
}

function meta::pure::changetoken::diff_generation::stripPath(element:PackageableElement[1]):String[1]
{
    stripVersionQualifier(elementToPath($element));
}

function meta::pure::changetoken::diff_generation::stripPaths(elements:PackageableElement[*]):String[*]
{
    $elements->map(m | $m->stripPath());
}

function meta::pure::changetoken::diff_generation::stripedPaths(x:PackageableElement[1], y:PackageableElement[1]):Integer[1]
{
    compare(stripPath($x), stripPath($y));
}

function meta::pure::changetoken::diff_generation::stripVersionQualifier(path:String[1]):String[1]
{
    $path->split('::')->fold({s:String[1], r:String[*] | if($s->matches('^v[^_]+_[^_]+_[^_]+$')->and($r->size() >= 2), | $r->take($r->size() - 2), | $r->concatenate($s)) }, [])->joinStrings('::');
}

function meta::pure::changetoken::diff_generation::getChangeTokens(newClasses:Class<Any>[*], oldClasses:Class<Any>[*], propertyRenames:Map<String, Map<String, String>>[0..1], classRenames:Map<String, String>[0..1], defaultValues:Map<String, Map<String, Any>>[0..1]):ChangeToken[*]
{
    let classRenamesReverse = $classRenames->map(m | flipMap($m));
    let propertyRenamesReverse = $propertyRenames->map(m | flipNestedMaps($m));
    concatenate(mergeChangeTokens(getAddedClass($classRenamesReverse, $newClasses, $oldClasses), getAddField($propertyRenamesReverse, $classRenamesReverse, $defaultValues, $newClasses, $oldClasses)), mergeChangeTokens(getRemovedClass($classRenames, $newClasses, $oldClasses), getRemoveField($propertyRenames, $classRenames, $defaultValues, $newClasses, $oldClasses)))
    ->concatenate(getRenameField($propertyRenames, $oldClasses))
    ->concatenate(getRenamedClass($classRenames, $oldClasses));
}

function meta::pure::changetoken::diff_generation::flipMap<K, V>(m:Map<K,V>[1]):Map<V, K>[1]
{
    newMap($m->keys()->map(k | pair($m->get($k)->toOne(), $k)));
}

function meta::pure::changetoken::diff_generation::flipNestedMaps<S, T, U>(m:Map<S, Map<T, U>>[1]):Map<S, Map<U, T>>[1]
{
    newMap($m->keys()->map(k | pair($k, $m->get($k)->toOne()->flipMap())));
}

function meta::pure::changetoken::diff_generation::mergeChangeTokens(x:ChangeToken[*], y:ChangeToken[*]):ChangeToken[*]
{
    $x->concatenate($y)->sort({x,y | $x->cast(@ClassChangeToken).class->compare($y->cast(@ClassChangeToken).class) });
}

function meta::pure::changetoken::diff_generation::getAddedClass(classRenames:Map<String, String>[0..1], newClasses:Class<Any>[*], oldClasses:Class<Any>[*]):ChangeToken[*]
{
    $newClasses
    ->filter(c | not(contains(stripPaths($oldClasses), lookupOrDefault($classRenames, stripPath($c)))))
    ->sort({x,y | stripedPaths($x, $y) })
    ->map(c | ^AddedClass(
            class=stripPath($c)
    ));
}

function meta::pure::changetoken::diff_generation::lookupOrDefault<T>(m:Map<T, T>[0..1], v:T[1]):T[1]
{
    if($m->isEmpty()->not()
    ->and($m->toOne()->keys()->contains($v)),
    | $m->toOne()->get($v)->toOne(),
    | $v);
}

function meta::pure::changetoken::diff_generation::lookupOrDefault<K, V>(m:Map<K, Map<V,V>>[0..1], k:K[1], v:V[1]):V[1]
{
    if($m->isEmpty()->not()
    ->and($m->toOne()->keys()->contains($k))
    ->and($m->toOne()->get($k)->toOne()->keys()->contains($v)),
    | $m->toOne()->get($k)->toOne()->get($v)->toOne(),
    | $v);
}

function meta::pure::changetoken::diff_generation::lookupOrAny<K, V>(m:Map<K, Map<V,Any>>[0..1], k:K[1], v:V[1], a:Any[1]):Any[1]
{
    if($m->isEmpty()->not()
    ->and($m->toOne()->keys()->contains($k))
    ->and($m->toOne()->get($k)->toOne()->keys()->contains($v)),
    | $m->toOne()->get($k)->toOne()->get($v)->toOne(),
    | $a);
}

function meta::pure::changetoken::diff_generation::getAddField(renamedProperties:Map<String, Map<String, String>>[0..1], classRenames:Map<String, String>[0..1], defaultValues:Map<String, Map<String, Any>>[0..1], newClasses:Class<Any>[*], oldClasses:Class<Any>[*]):ChangeToken[*]
{
    $newClasses
    ->map(c | $c.properties->map(p | pair($c, $p)))
    ->filter(cp | $oldClasses->map(c | $c.properties->map(p | pair(stripPath($c), $p.name->toOne())))->contains(pair(lookupOrDefault($classRenames, stripPath($cp.first)),
    lookupOrDefault($renamedProperties, lookupOrDefault($classRenames, stripPath($cp.first)), $cp.second.name->toOne())))->not())
    ->filter(cp | $cp.second.name != 'version')
    ->sort({x,y | compare($x.second.name->toOne(), $y.second.name->toOne()) })
    ->sort({x,y | stripedPaths($x.first, $y.first) })
    ->map(cp | ^AddField(
            class=stripPath($cp.first),
            fieldName=$cp.second.name->toOne(),
            fieldType=stripVersionQualifier(printGenericType($cp.second.genericType)) + '[' + printMultiplicity($cp.second.multiplicity) + ']',
            safeCast=true,
            defaultValue=^ConstValue(value=lookupOrAny($defaultValues, stripPath($cp.first), $cp.second.name->toOne(), if($cp.second.defaultValue->isEmpty(), | '', | $cp.second.defaultValue.functionDefinition->toOne()->cast(@Function<{->Any[1]}>)->eval()->toJSONElement([], 100, config(true, true, true, true, '@type', true))->stripVersionQualifiers())))
    ));
}

function meta::pure::changetoken::diff_generation::stripVersionQualifiers(input:JSONElement[1]):JSONElement[1]
{
    $input->match([
        o:JSONObject[1] | newJSONObject($o.keyValuePairs->filter(kv|$kv.key.value == '@type')->map(kv | ^JSONKeyValue(key = $kv.key, value = ^JSONString(value=$kv.value->cast(@JSONString).value->stripVersionQualifier())))->concatenate($o.keyValuePairs->filter(kv|$kv.key.value != '@type')->map(kv | ^JSONKeyValue(key = $kv.key, value = $kv.value->unzap_value()->stripVersionQualifiers())))),
        e:JSONElement[1] | $e
    ])
}

function meta::pure::changetoken::diff_generation::getRemovedClass(classRenames:Map<String, String>[0..1], newClasses:Class<Any>[*], oldClasses:Class<Any>[*]):ChangeToken[*]
{
    $oldClasses
    ->filter(c | not(contains(stripPaths($newClasses), lookupOrDefault($classRenames, stripPath($c)))))
    ->sort({x,y | stripedPaths($x, $y) })
    ->map(c | ^RemovedClass(
            class=stripPath($c)
    ));
}

function meta::pure::changetoken::diff_generation::getRemoveField(renamedProperties:Map<String, Map<String, String>>[0..1], classRenames:Map<String, String>[0..1], defaultValues:Map<String, Map<String, Any>>[0..1], newClasses:Class<Any>[*], oldClasses:Class<Any>[*]):ChangeToken[*]
{
    $oldClasses
    ->map(c | $c.properties->map(p | pair($c, $p)))
    ->filter(cp | $newClasses->map(c | $c.properties->map(p | pair(stripPath($c), $p.name->toOne())))->contains(pair(lookupOrDefault($classRenames, stripPath($cp.first)),
    lookupOrDefault($renamedProperties, stripPath($cp.first), $cp.second.name->toOne())))->not())
    ->filter(cp | $cp.second.name != 'version')
    ->sort({x,y | compare($x.second.name->toOne(), $y.second.name->toOne()) })
    ->sort({x,y | stripedPaths($x.first, $y.first) })
    ->map(cp | ^RemoveField(
            class=stripPath($cp.first),
            fieldName=$cp.second.name->toOne(),
            fieldType=stripVersionQualifier(printGenericType($cp.second.genericType)) + '[' + printMultiplicity($cp.second.multiplicity) + ']',
            safeCast=true,
            defaultValue=^ConstValue(value=lookupOrAny($defaultValues, stripPath($cp.first), $cp.second.name->toOne(), if($cp.second.defaultValue->isEmpty(), | '', | $cp.second.defaultValue.functionDefinition->toOne()->cast(@Function<{->Any[1]}>)->eval())))
    ));
}

function meta::pure::changetoken::diff_generation::getRenameField(renamedProperties:Map<String, Map<String, String>>[0..1], oldClasses:Class<Any>[*]):ChangeToken[*]
{
    if($renamedProperties->isEmpty(), | [], |
    $oldClasses
    ->map(c | $c.properties->map(p | pair($c, $p)))
    ->filter(cp | $renamedProperties->toOne()->keys()->contains(stripPath($cp.first))->and($renamedProperties->toOne()->get(stripPath($cp.first))->toOne()->keys()->contains($cp.second.name->toOne())))
    ->filter(cp | $cp.second.name != 'version')
    ->sort({x,y | compare($x.second.name->toOne(), $y.second.name->toOne()) })
    ->sort({x,y | stripedPaths($x.first, $y.first) })
    ->map(cp | ^RenameField(
            class=stripPath($cp.first),
            oldFieldName=$cp.second.name->toOne(),
            newFieldName=$renamedProperties->toOne()->get(stripPath($cp.first))->toOne()->get($cp.second.name->toOne())->toOne()
    )));
}

function meta::pure::changetoken::diff_generation::getRenamedClass(renamedClasses:Map<String, String>[0..1], oldClasses:Class<Any>[*]):ChangeToken[*]
{
    if($renamedClasses->isEmpty(), | [], |
    $oldClasses
    ->filter(c | $renamedClasses->toOne()->keys()->contains(stripPath($c)))
    ->sort({x,y | stripedPaths($x, $y) })
    ->map(c | ^RenamedClass(
            class=stripPath($c),
            newName=$renamedClasses->toOne()->get(stripPath($c))->toOne()
    )));
}
